<details><summary>Task</summary>

- Создать любой gradle проект
- Проект должен быть совместим с java 17
- Придерживаться GitFlow: master -> develop -> feature/fix
- Создать реализацию кэша, используя алгоритмы LRU и LFU
- Создать в приложении слои service и dao (service будет вызывать слой dao, слой dao будет временная замена database). В этих сервисах реализовать CRUD операции для работы с entity. Работу организовать через интерфейсы.
- Результат работы dao должен синхронизироваться с кешем через proxy (или кастомная аннотация, или АОП/aspectj). При работе с entity оперируем id. Алгоритм работы с кешем:
  - GET - ищем в кеше и если там данных нет, то достаем объект из dao, сохраняем в кеш и возвращаем
  - POST - сохраняем в dao и потом сохраняем в кеше
  - DELETE - удаляем из dao и потом удаляем из кеша
  - PUT - обновление/вставка в dao и потом обновление/вставка в кеше
- Алгоритм и максимальный размер коллекции должны читаться из файла resources/application.yml
- Создать entity, в нем должно быть поле id и еще минимум 4 поля
- Service работает с dto
- Объекты (dto), которые принимает service, должны валидироваться. В т.ч. добавить regex валидацию
- Кеши должны быть покрыты unit tests
- Должен содержать javadoc и описанный README.md
- Использовать lombok
- *Реализовать метод для получения информации в формате xml
- Заполнить и отправить форму


# Доп. задание:
- ***Самописный JsonParser подтягивать как библиотеку и парсировать json через него
- ***В самописный JsonParser добавить возможность работы с xml
</details>

## Реализация
- интерактивная работа в терминале при запуске программы
- окружение в docker compose
- выполнены все обязательные пункты (не хватка времени по личным обстоятельствам)
- над Main классом указан пример json файла для добавления юзеров

<details><summary>TASK 8</summary>

- Создать любой gradle проект
- Придерживаться GitFlow: master -> develop -> feature/fix
- Создать два класса:
- Клиент - имеет список данных в виде List<Integer> от 1 до n.  Отдельными потоками, по случайному индексу из списка выбирается значение (метод remove()) и в виде запроса (класс с int -полем), содержащего это значение, отправляется на сервер в асинхронном режиме (например отправляются со случайной задержкой между запросами - диапазон - от 100 до 500 мс). Количество запросов равно размеру первоначального списка. Контроль: после отправки всех запросов размер списка данных = 0
- Сервер - получает запросы от клиента. Метод обрабатывающий запрос имеет задержку в виде рандомного инта. Диапазон - от 100 до 1000 мс. Сервер обрабатывает запросы, используя общий для всех потоков ресурс: List<Integer>, в который складываются значения приходящие с запросом. В ответ от сервера передаем размер листа на момент формирования ответа (класс с int-полем). Итоговый контроль правильности данных на стороне сервера: список (общий ресурс) должен содержать значения от 1 до n без пробелов, повторений, размерность его должна составлять n
- Клиент получает от сервера ответ и в общий для всех потоков ресурс accumulator суммирует значение из ответа от сервера. Итоговый контроль: accumulator = (1+n) * (n/2). Т.е. для диапазона 1-100 ответ должен быть 5050
- Протестировать эти два класса с проверкой многопоточности
- Протестировать взаимодействие клиента - сервера отдельным тестом (интеграционный) - обязательно
- В реализации использовать классы пакета java.util.concurrent (обязательно Lock, Callable, Executor, Future, остальное - по выбору)
- Методы класса Object (относящиеся к потокам и монитору) и ключевое слово synchronized НЕ использовать

</details>


## Комментарии к 8 таске
Печать в pdf реализовона для записи всех данных обрабатываемых при всех операция CRUD.
По умолчанию установлена директория pdf но можно изменить с любой вложенностью (будет создаваться непосредственно в директории проекта).
Печать происходит в файлы с названием операции и временем создания файла.
ДАнные заносяться в таблицу. Класс [PdfMakerClevertec](src/main/java/org/example/printer/impl/PdfMakerClevertec.java) реализует 
интерйейс [DockMaker](src/main/java/org/example/printer/DockMaker.java) для печати и задания директории по умолчанию


<details><summary>TASK 10</summary>

- Взять за основу проект из лекции паттернов
- Придерживаться GitFlow: master -> develop -> feature/fix
- Написать CRUD для всех таблиц
- Для метода .findAll() сделать пагинацию (по умолчанию 20 элементов на странице, если pagesize не задан)
- Сделать GET метод, для генерации чека в формате pdf (если товара не существует, тогда генерируем ошибку)
- Прикрутить возможность инициализации бд и наполнения её данными с помощью параметра в application.yml файле, т.е. чтобы при подъеме приложения,  приложение создавало схему, таблицы и наполняло таблицы данными
- Фильтры
- UI НЕ нужен

</details>

## Комментарии к 10 таске
Запуск проекта производится таким же образом (всё упаковано в компоуз) но для сервелетов достаточно запустить компоуз
и дождаться сборки и запуска проекта (через несколько минут, в зависимости от скорости интернета) на адресе (при запуске на локальной машине)
http://localhost:7777/api/customer и http://localhost:7777/api/customers можно будет получать информацию.
Все методы возвращают pdf файл с полученным, обновлённым, добавленным или удалённым пользователем

Для http://localhost:7777/api/customers
- Досутпен только метод get (параметры limit и page) где limit - количество строк на странице и page номер страницы
по умолчанию параметры равны 4 и 1 соответственно
- Для доступа к данному ресту необходимо добавить в заголовок запроса key - customToken с любым значением (реализовано чеерез фильтер)
- Размер страницы п умолчанию устанавливается в конфиг файле

Для http://localhost:7777/api/customer
- Доступны get post put delete методы (при добавлении и удалении в ответе с некорректными данными приходит пример)

База данных инициализируется по конфиг файлу. Так как база postgres то инициализация была реализована через bash скрипты (это то что пришло мне на ум так как я немного погуглив не напоролся на другйю реализацию)

 П С  Напоминание что для старта проекта достаточно запуска компоуза 
 (в противном случаем нужна перенастройка проета. 
 Так как все данные небыло необходимости выносить в конфиг они указаны в коде, 
 Я всегда запускал и отлаживал проект в среде настроеной в compose. Проверено на Windows и linux) 


## Запуск проекта
1. Установить утилиты docker & docker-compose (необходимые образы - postgres:13.3, dpage/pgadmin4:5.7, ubuntu)
2. Из директории в проекте ./dockerPG выполнить команду `docker compose build && docker compose up`
3. После зайти в запущенный контейнер bank_app (`docker ps` -> `docker exec -it xxx bash`)
   <br>Где xxx - CONTAINER ID (dockerpg-task_app) из 1 команды в текущем пункте
4. В терминале контейнера выполнить `bash startApp.sh` - Консольное приложение запущенно и готово к использованию


## Параметры конфиг файла [config](./config.yml)
- typeCache: LRU или LFU
- capacity: целое число ёмкости кэша