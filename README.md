<details><summary>Task</summary>

- Создать любой gradle проект
- Проект должен быть совместим с java 17
- Придерживаться GitFlow: master -> develop -> feature/fix
- Создать реализацию кэша, используя алгоритмы LRU и LFU
- Создать в приложении слои service и dao (service будет вызывать слой dao, слой dao будет временная замена database). В этих сервисах реализовать CRUD операции для работы с entity. Работу организовать через интерфейсы.
- Результат работы dao должен синхронизироваться с кешем через proxy (или кастомная аннотация, или АОП/aspectj). При работе с entity оперируем id. Алгоритм работы с кешем:
  - GET - ищем в кеше и если там данных нет, то достаем объект из dao, сохраняем в кеш и возвращаем
  - POST - сохраняем в dao и потом сохраняем в кеше
  - DELETE - удаляем из dao и потом удаляем из кеша
  - PUT - обновление/вставка в dao и потом обновление/вставка в кеше
- Алгоритм и максимальный размер коллекции должны читаться из файла resources/application.yml
- Создать entity, в нем должно быть поле id и еще минимум 4 поля
- Service работает с dto
- Объекты (dto), которые принимает service, должны валидироваться. В т.ч. добавить regex валидацию
- Кеши должны быть покрыты unit tests
- Должен содержать javadoc и описанный README.md
- Использовать lombok
- *Реализовать метод для получения информации в формате xml
- Заполнить и отправить форму


# Доп. задание:
- ***Самописный JsonParser подтягивать как библиотеку и парсировать json через него
- ***В самописный JsonParser добавить возможность работы с xml
</details>

## Реализация
- интерактивная работа в терминале при запуске программы
- окружение в docker compose
- выполнены все обязательные пункты (не хватка времени по личным обстоятельствам)
- над Main классом указан пример json файла для добавления юзеров

<details><summary>TASK 8</summary>

- Создать любой gradle проект
- Придерживаться GitFlow: master -> develop -> feature/fix
- Создать два класса:
- Клиент - имеет список данных в виде List<Integer> от 1 до n.  Отдельными потоками, по случайному индексу из списка выбирается значение (метод remove()) и в виде запроса (класс с int -полем), содержащего это значение, отправляется на сервер в асинхронном режиме (например отправляются со случайной задержкой между запросами - диапазон - от 100 до 500 мс). Количество запросов равно размеру первоначального списка. Контроль: после отправки всех запросов размер списка данных = 0
- Сервер - получает запросы от клиента. Метод обрабатывающий запрос имеет задержку в виде рандомного инта. Диапазон - от 100 до 1000 мс. Сервер обрабатывает запросы, используя общий для всех потоков ресурс: List<Integer>, в который складываются значения приходящие с запросом. В ответ от сервера передаем размер листа на момент формирования ответа (класс с int-полем). Итоговый контроль правильности данных на стороне сервера: список (общий ресурс) должен содержать значения от 1 до n без пробелов, повторений, размерность его должна составлять n
- Клиент получает от сервера ответ и в общий для всех потоков ресурс accumulator суммирует значение из ответа от сервера. Итоговый контроль: accumulator = (1+n) * (n/2). Т.е. для диапазона 1-100 ответ должен быть 5050
- Протестировать эти два класса с проверкой многопоточности
- Протестировать взаимодействие клиента - сервера отдельным тестом (интеграционный) - обязательно
- В реализации использовать классы пакета java.util.concurrent (обязательно Lock, Callable, Executor, Future, остальное - по выбору)
- Методы класса Object (относящиеся к потокам и монитору) и ключевое слово synchronized НЕ использовать

</details>

## Комментарии к 8 таске
Печать в pdf реализовона для записи всех данных обрабатываемых при всех операция CRUD.
По умолчанию установлена директория pdf но можно изменить с любой вложенностью (будет создаваться непосредственно в директории проекта).
Печать происходит в файлы с названием операции и временем создания файла.
ДАнные заносяться в таблицу. Класс [PdfMakerClevertec](src/main/java/org/example/printer/impl/PdfMakerClevertec.java) реализует 
интерйейс [DockMaker](src/main/java/org/example/printer/DockMaker.java) для печати и задания директории по умолчанию

## Запуск проекта
1. Установить утилиты docker & docker-compose (необходимые образы - postgres:13.3, dpage/pgadmin4:5.7, ubuntu)
2. Из директории в проекте ./dockerPG выполнить команду `docker compose build && docker compose up`
3. После зайти в запущенный контейнер bank_app (`docker ps` -> `docker exec -it xxx bash`)
   <br>Где xxx - CONTAINER ID (dockerpg-task_app) из 1 команды в текущем пункте
4. В терминале контейнера выполнить `bash startApp.sh` - Консольное приложение запущенно и готово к использованию


## Параметры конфиг файла [config](./config.yml)
- typeCache: LRU или LFU
- capacity: целое число ёмкости кэша